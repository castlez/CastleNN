// this is the neural net class 
// // TODO: 8/15/2016  will be updated as the methods are needed

import java.util.Arrays;
import java.util.StringJoiner;
import java.util.Vector;
import java.util.regex.Matcher;

/**
 * Created by Jonny on 8/15/2016.
 * Manages the neural net
 */

public class NeuralNet {

    private Integer numInputs;

    private Integer numOutputs;

    private Integer numHiddenLayers;

    private Integer numNeuronsPerHiddenLyr;

    private Vector<NeuronLayer> vecLayers;

    //if you pass null in for vecLayers, you must call init to build the neural network
    public NeuralNet(Integer numInputs, Integer numOutputs, Integer numHiddenLayers, Integer numNeuronsPerHiddenLyr, Vector<NeuronLayer> vecLayers) {
        this.numInputs = numInputs;
        this.numOutputs = numOutputs;
        this.numHiddenLayers = numHiddenLayers;
        this.numNeuronsPerHiddenLyr = numNeuronsPerHiddenLyr;
        this.vecLayers = vecLayers!=null ? vecLayers : new Vector<NeuronLayer>();
    }

    //initializes a 3 layer neural net
    public void init3Layer() {
        //create input layer
        NeuronLayer templayer = new NeuronLayer(numInputs, 1);
        vecLayers.add(templayer);

        //the hidden layer
        templayer = new NeuronLayer(numNeuronsPerHiddenLyr, numInputs);
        vecLayers.add(templayer);

        //output layer
        templayer = new NeuronLayer(numOutputs, numNeuronsPerHiddenLyr);
        vecLayers.add(templayer);
    }

    Vector<Double> getWeights(){
        Vector<Double> myweights = new Vector<Double>();
        for (NeuronLayer layer : vecLayers) {
            myweights.addAll(layer.getWeights());
        }
        return myweights;
    }

    //returns the total number of weights in the net
    Integer GetNumberOfWeights(){
        Integer numweights = 0;
        for (NeuronLayer nl : vecLayers) {
            numweights += nl.getWeights().size();
        }
        return numweights;
    }



    //replaces the weights with new ones
    void putWeights(Vector<Double> weights){
        for (NeuronLayer nl : vecLayers) {
            Vector<Double> tempw = new Vector<Double>();
            for (int i = 0; i < nl.getWeights().size()/nl.numNeurons;i++) { //might want to find a better way to do this
                tempw.add(weights.get(i));
            }
            nl.putWeights(tempw);
        }
    }



    /* calculates the outputs from a set of inputs */
    Vector<Double> feedforward(Vector<Double> inputs){
        Vector<Double> outputs = new Vector<>();
        Double sum = 0.0;
        for (int i = 0; i < numNeuronsPerHiddenLyr;i++) {
            sum = 0.0;
            for (int k = 0; k < inputs.size(); k++) {
                sum += vecLayers.get(0).vecNeurons.get(k).activate(new Vector(Arrays.asList(inputs.get(k))));
            }
        }
        // calc activation input->hiddenlayer

        //TODO:sum +=                   current progress

        return outputs;
    }

    //takes outputs generated by the feedforward
    //and adjusts weights
    NeuralNet backprop(Vector<Double> outputs, Vector<Double> expected){
        Vector<Double> errh = new Vector<>();
        Vector<Double> erro = new Vector<>();
        Double terr = 0.0;
        // Calculate the output layer error
        for (int i = 0; i < numOutputs; i++) {
            terr = (expected.get(i) - outputs.get(i)) * sigmoidDerivative(outputs.get(i));
            erro.add(terr);
        }
        // Calculate the hidden layer error
        Vector<Double> tweights = new Vector<>();
        int wi;
        for (int i = 0; i < numNeuronsPerHiddenLyr; i++) {
            terr = 0.0;
            for (int k = 0; k < numOutputs; k++) {
                terr += erro.get(k) ;
            }
            errh.add(terr); //*sigmoidderivitive(hidden layer neuron i's activation)
        }
        // Update the weights for the output layer

        // Update the weights for the hidden layer



        //return newly weighted nn
        return this;
    }

    private static Double sigmoidDerivative(final Double val)
    {
        return (val * (1.0 - val));
    }

    //sigmoid response curve
    // originally Double Sigmoid(Double activation, Double response)
    // pretty sure the second argument is always 1 for most cases
    Double Sigmoid(Double activation){return 1/(1 + Math.pow(Math.E, (-1)*activation));}

    @Override
    public String toString(){
        if (vecLayers.size() < 1) {
            return "empty neural net";
        }
        String outString = vecLayers.get(0).toString();
        for (int i = 1; i < vecLayers.size(); i++) {
            outString += "\n\n" + vecLayers.get(i).toString();
        }
        return outString;
    }




}
